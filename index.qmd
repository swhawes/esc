---
title: "ESC-PA_JCMS"
format: html
---

```{r}
#| echo: FALSE # The content of this code block will not be rendered
#| output: FALSE # Output from this code block will not be rendered

# This code configures knitr code chunk options

knitr::opts_chunk$set(
    echo = T, message = F, warning = F, error = F, output = T,
    comment = NA, cache = T, code_folding = T,
    R.options = list(width = 220, digits = 3),
    fig.align = "center",
    out.width = "75%", fig.asp = .75
)
```

```{r}
#| echo: false
#| warning: false
#| output: false

library(tidyverse)
library(readxl)
library(openxlsx)
library(kableExtra)
library(psych)
library(stringr)
library(tidyr)
library(gtsummary)
library(purrr)

# Read the data from an Excel file
merged <- read_excel("/Users/shawes/PA_JCMS/data/Merged_Files_NoRecid.xlsx")

merged <- merged %>%
    rename(
        service_name_1 = "Service Name", # Adjust indices as appropriate
        service_type_1 = "Service Type"
    )

# Assuming 'df' is your dataframe
merged <- merged %>%
    rename_all(~ str_to_lower(str_replace_all(., pattern = " ", replacement = "_")))

```

```{r}
#| echo: false
#| warning: false

# Compute the percentage of missing data for each column
missing_percentages <- merged %>%
    dplyr::summarise(across(everything(), ~ round(mean(is.na(.)) * 100))) %>%
    tidyr::pivot_longer(everything(), names_to = "column", values_to = "percent_missing")

# Print the results to check
print(missing_percentages)

```


```{r}
#| echo: false
#| warning: false
#| output: false

# Identify columns with less than 90% missing data
cols_to_keep <- missing_percentages %>%
    filter(percent_missing < 90) %>%
    pull(column)

# Filter the original dataframe to keep these columns
merged <- merged %>%
    select(all_of(cols_to_keep))

merged <- merged %>%
    select(where(~ mean(is.na(.)) * 100 < 90))

# Set character columns to factors
merged <- merged %>%
    mutate(across(where(is.character), as.factor))

# Subset the dataframe to include only 'factor' or 'numeric' columns
merged <- merged %>%
    select(where(~ is.factor(.) || is.numeric(.)))

```


```{r}
#| echo: false
#| warning: false

# List the data type for each column in the dataframe 'merged'
column_types <- map_chr(merged, class)
# print(column_types)

# Count the number of each type of data
type_counts <- tibble(type = column_types) %>%
    count(type)
# Print the results to check
print(type_counts)
```


```{r}
#| echo: false
#| warning: false

# Create a named list of the number of levels for factor variables
factor_levels <- merged %>%
    select_if(is.factor) %>%
    map_dfr(~ nlevels(.), .id = "Variable") # Using map_dfr to return a dataframe

# Print the results
print(factor_levels)

```

# Descriptives Test for Subset I of Variables
```{r}
#| echo: false
#| warning: false

# Calculate missing percentages for each column of interest
missing_percentages <- merged %>%
    select(setting, gender, race, ethnicity, racnicity, age_at_service_start, age_at_first_referral_date) %>%
    summarise(across(everything(), ~ sum(is.na(.)) / n() * 100, .names = "missing_{.col}"))

# Convert to a format suitable for addition to gtsummary table
missing_percentages <- pivot_longer(missing_percentages, cols = everything(), names_to = "variable", values_to = "missing_percent")

# Prepare the descriptive statistics table
descriptives_table <- merged %>%
    select(setting, gender, race, ethnicity, racnicity, age_at_service_start, age_at_first_referral_date) %>%
    tbl_summary(
        by = setting, # Optional: if you want to group by gender
        missing = "no",
        # label = list(Setting, ~"Setting"),
        statistic = list(
            all_continuous() ~ "{mean} ({sd})",
            all_categorical() ~ "{p}%"
        )
    ) %>%
    modify_header(all_stat_cols() ~ "**{level}**<br>N = {n}")

# Print the table to see if it works without the modifications
print(descriptives_table)

```

# Descriptives Test for Subset II of Variables
```{r}
#| echo: false
#| warning: false
#| output: false

# Specify the variables to include
variables_to_include <- c(
    "setting", "service_type",
    "target_dosage", "target_duration",
    "number_of_youth:_\r\nscoring_low_on_the_yls",
    "service_classification", "name_brand_service",
    "total_pts._risk_level", "total_pts._amount_of_service",
    "target_weeks", "target_hours"
)

# Filter the merged dataframe to include only the specified variables, along with 'Setting' if it's a grouping variable
descriptive_data <- merged %>%
    select(setting, all_of(variables_to_include))

```

```{r}
#| echo: false
#| warning: false

# Generate descriptive statistics table
# Prepare the descriptive statistics table
descriptives_table <- descriptive_data %>%
    select(
        "setting", "service_type",
        "target_dosage", "target_duration",
        "number_of_youth:_\r\nscoring_low_on_the_yls",
        "service_classification", "name_brand_service",
        "total_pts._risk_level", "total_pts._amount_of_service",
        "target_weeks", "target_hours"
    ) %>%
    tbl_summary(
        by = setting, # Optional: if you want to group by gender
        missing = "no",
        # label = list(Setting, ~"Setting"),
        statistic = list(
            all_continuous() ~ "{mean} ({sd})",
            all_categorical() ~ "{p}%"
        )
    ) %>%
    modify_header(all_stat_cols() ~ "**{level}**<br>N = {n}")

# Print the table
print(descriptives_table)

```







 












