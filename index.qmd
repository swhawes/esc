---
title: "ESC-Revalidation"
---

```{r}
#| echo: false
#| warning: false
#| output: false

library(tidyverse)
library(readxl)
library(openxlsx)
library(kableExtra)
library(psych)
library(stringr)
library(tidyr)
library(gtsummary)
library(purrr)
library(gt)
library(scales)
library(janitor)
library(DT)
library(dlookr)
library(htmlwidgets)

# Read the data from an Excel file
merged <- read_excel("/Users/shawes/PA_JCMS/data/Merged_Files_NoRecid.xlsx")

```

```{r}
#| echo: false
#| warning: false
#| output: false

## % Missingness by Variable

# Calculate the percentage of missing data for each column
missing_data_percentages <- merged %>%
    summarise(across(everything(), ~ mean(is.na(.)) * 100)) %>%
    pivot_longer(cols = everything(), names_to = "variable", values_to = "missing_percentage")

# Filter out columns with >= 90% missing data
columns_to_keep <- missing_data_percentages %>%
    filter(missing_percentage < 90) %>%
    pull(variable)

# Select the columns to keep
merged <- merged %>%
    select(all_of(columns_to_keep))


```

```{r}
#| echo: false
#| warning: false
#| output: false

# List of sensitive variables to exclude
sensitive_vars <- c("unique_id", "youth_num_in_cohort", "mhs2_juvenile_id", "dob", "assessment_po")

# Function to clean variable names
clean_variable_names <- function(merged) {
    cleaned_names <- merged %>%
        clean_names() %>%
        names() %>%
        str_replace_all("[^[:alnum:]_]", "_") %>%
        str_replace_all("__+", "_") %>%
        str_trim() %>%
        tolower()

    names(merged) <- cleaned_names
    return(merged)
}

```

```{r}
#| echo: false
#| warning: false
#| output: false

# Function to calculate means and standard deviations for numeric columns
calculate_means_sds <- function(merged) {
    means_sds <- sapply(merged, function(x) {
        if (is.numeric(x)) {
            mean_value <- round(mean(x, na.rm = TRUE), 2)
            sd_value <- round(sd(x, na.rm = TRUE), 2)
            paste0(mean_value, " (", sd_value, ")")
        } else {
            NA
        }
    })
    return(means_sds)
}

# Function to set variable types based on dlookr diagnostics
set_variable_types <- function(merged, types) {
    for (i in 1:nrow(types)) {
        var <- types$variables[i]
        type <- types$types[i]
        if (type == "numeric") {
            merged[[var]] <- as.numeric(merged[[var]])
        } else if (type == "factor") {
            merged[[var]] <- as.factor(merged[[var]])
        } else if (type == "integer") {
            merged[[var]] <- as.integer(merged[[var]])
        } else if (type == "character") {
            merged[[var]] <- as.character(merged[[var]])
        }
        # Add other types as necessary
    }
    return(merged)
}

# Function to convert character variables to factors if they have a limited number of unique values
convert_char_to_factor <- function(merged) {
    merged <- merged %>%
        mutate(across(where(is.character), as.factor))
    return(merged)
}

# Function to calculate the mode for factor variables
calculate_modes <- function(merged) {
    modes <- sapply(merged, function(x) {
        if (is.factor(x)) {
            mode_value <- names(sort(table(x), decreasing = TRUE)[1])
            mode_count <- max(table(x))
            mode_percentage <- (mode_count / length(x)) * 100
            paste0(mode_value, " (", round(mode_percentage, 2), "%)")
        } else {
            NA
        }
    })
    return(modes)
}

# Function to calculate date statistics for POSIXct columns
calculate_date_statistics <- function(merged) {
    date_stats <- sapply(merged, function(x) {
        if (inherits(x, "POSIXct")) {
            min_date <- format(min(x, na.rm = TRUE), "%Y-%m-%d")
            max_date <- format(max(x, na.rm = TRUE), "%Y-%m-%d")
            num_unique_dates <- length(unique(x))
            median_date <- format(median(x, na.rm = TRUE), "%Y-%m-%d")
            paste0(min_date, " to ", max_date)
        } else {
            NA
        }
    })
    return(date_stats)
}

# Function to count the number of levels for factor variables
count_levels <- function(merged) {
    num_levels <- sapply(merged, function(x) if (is.factor(x)) length(levels(x)) else NA)
    return(num_levels)
}

# Function to mask sensitive data, only for existing columns
mask_sensitive_data <- function(merged, sensitive_vars) {
    existing_sensitive_vars <- intersect(names(merged), sensitive_vars)
    if (length(existing_sensitive_vars) > 0) {
        merged <- merged %>%
            mutate(across(all_of(existing_sensitive_vars), ~"Masked"))
    }
    return(merged)
}

# List of sensitive variables to exclude
sensitive_vars <- c("unique_id", "youth_num_in_cohort", "mhs2_juvenile_id", "dob", "assessment_po")

```

```{r}
#| echo: false
#| warning: false
#| output: false

# Apply the cleaning function to the dataset
merged_clean <- clean_variable_names(merged)

# Convert character variables to factors
merged_clean <- convert_char_to_factor(merged_clean)

# Determine variable types using dlookr
variable_types <- diagnose(merged_clean) %>%
    select(variables, types)

# Set variable types based on dlookr diagnostics
merged_clean <- set_variable_types(merged_clean, variable_types)

# Mask sensitive data
merged_clean <- mask_sensitive_data(merged_clean, sensitive_vars)

# Create a mapping table of original and cleaned names, excluding sensitive variables
mapping_table <- tibble(
    original_name = names(merged),
    cleaned_name = names(merged_clean)
) %>%
    filter(!cleaned_name %in% sensitive_vars)

```

```{r}
#| echo: false
#| warning: false
#| output: false

# Calculate means and standard deviations for numeric columns
means_sds <- calculate_means_sds(merged_clean)

# Calculate modes for factor columns
modes <- calculate_modes(merged_clean)

# Calculate date statistics for POSIXct columns
date_statistics <- calculate_date_statistics(merged_clean)

# Count the number of levels for factor variables
num_levels <- count_levels(merged_clean)
```

```{r}
#| echo: false
#| warning: false
#| output: false

# Combine means, modes, date statistics, and sensitive summaries into separate columns
mapping_table <- mapping_table %>%
    mutate(
        mean_sd = means_sds[!names(means_sds) %in% sensitive_vars],
        mode = modes[!names(modes) %in% sensitive_vars],
        date_range = date_statistics[!names(date_statistics) %in% sensitive_vars],
        num_levels = num_levels[!names(num_levels) %in% sensitive_vars]
    ) %>%
    left_join(variable_types, by = c("cleaned_name" = "variables"))

# Ensure all numeric values in the table are rounded to two decimal places
mapping_table <- mapping_table %>%
    mutate(across(where(is.numeric), ~ round(., 2)))

# Reorder the columns so that summary_statistic is before original_name
mapping_table <- mapping_table %>%
    select(cleaned_name, mean_sd, mode, date_range, num_levels, original_name, types)
```

## Table 1: Overall Descrptives
```{r}
#| echo: false
#| warning: false

# Render the table using DT::datatable with tooltips and better formatting
datatable(mapping_table,
    rownames = FALSE,
    caption = "Summary Statistics Table",
    extensions = "Buttons",
    options = list(
        pageLength = 10,
        scrollX = TRUE,
        scrollY = "500px",
        dom = "Bfrtip",
        buttons = c("copy", "csv", "excel", "pdf", "print")
    )
) %>%
    formatStyle(
        columns = names(mapping_table),
        valueColumns = "types",
        backgroundColor = styleEqual(c("numeric", "factor", "POSIXct"), c("lightblue", "lightgreen", "lightpink"))
    )


```
## Table 2: Continuous Outcomes by Setting
```{r}
#| echo: false
#| warning: false

# Filter to keep only numeric variables
numeric_vars <- merged_clean %>% select(where(is.numeric))

# Add the 'setting' variable back to the numeric-only data frame
numeric_vars <- numeric_vars %>%
  mutate(setting = merged_clean$setting)

# Create a summary table for both settings
summary_table <- tbl_summary(
  data = numeric_vars,
  by = setting,
  missing = "no",
  statistic = list(
    all_continuous() ~ "{mean} ({sd})"
  )
) %>%
  add_p() %>%
  bold_labels() %>%
  modify_header(label ~ "**Variable**") %>%
  modify_caption("**Table 1: Descriptive Statistics by Setting**") %>%
  modify_footnote(
    all_stat_cols() ~ "Mean (SD) for continuous variables"
  )

# Convert the gtsummary table to a data frame
summary_table_df <- as_tibble(summary_table, col_labels = TRUE)

# Rename columns to match expected names
colnames(summary_table_df) <- c("Variable", "C", "R", "p_value")

# Render the table using DT
datatable(
  summary_table_df,
  extensions = 'Buttons',
  options = list(
    dom = 'Bfrtip',
    buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
    pageLength = 5,
    autoWidth = TRUE,
    columnDefs = list(list(width = '200px', targets = 1))
  )
) %>% formatStyle(
  'p_value', target = 'row',
  backgroundColor = styleInterval(0.05, c('white', 'yellow'))
)

# Save the DT output as an HTML file
saveWidget(
  datatable(
    summary_table_df,
    extensions = 'Buttons',
    options = list(
      dom = 'Bfrtip',
      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
      pageLength = 5,
      autoWidth = TRUE,
      columnDefs = list(list(width = '200px', targets = 1))
    )
  ) %>% formatStyle(
    'p_value', target = 'row',
    backgroundColor = styleInterval(0.05, c('white', 'yellow'))
  ),
  "summary_table.html"
)




```



```{r}
#| echo: false
#| warning: false
#| output: false

## Table 3: Categorical Outcomes by Setting

# Load necessary libraries
library(tidyverse)
library(readxl)
library(gtsummary)
library(DT)
library(htmlwidgets)

# Filter to keep only factor variables with <= 20 levels
factor_vars <- merged_clean %>%
  select(where(~ is.factor(.) && nlevels(.) <= 20))

# Add the 'setting' variable back to the factor-only data frame
factor_vars <- factor_vars %>%
  mutate(setting = merged_clean$setting)

# Ensure that the 'setting' variable is a factor
factor_vars$setting <- as.factor(factor_vars$setting)

# Create a summary table for factor variables with <= 20 levels
factor_summary_table <- tbl_summary(
  data = factor_vars,
  by = "setting",
  missing = "no",
  statistic = list(
    all_categorical() ~ "{n} ({p}%)"
  )
) %>%
  add_p() %>%
  bold_labels() %>%
  modify_header(label ~ "**Variable**") %>%
  modify_caption("**Table 2: Descriptive Statistics for Factor Variables with ≤ 20 Levels by Setting**") %>%
  modify_footnote(
    all_stat_cols() ~ "N (%) for categorical variables"
  )

# Convert the gtsummary table to a data frame
factor_summary_table_df <- as_tibble(factor_summary_table, col_labels = TRUE)

# Rename columns to match expected names
colnames(factor_summary_table_df) <- c("Variable", "C", "R", "p_value")

# Render the table using DT with enhanced aesthetics
datatable(
  factor_summary_table_df,
  extensions = 'Buttons',
  options = list(
    dom = 'Bfrtip',
    buttons = list(
      'copy', 'csv', 'excel', 'pdf', 'print'
    ),
    pageLength = 10,
    autoWidth = TRUE,
    columnDefs = list(
      list(width = '150px', targets = 0),
      list(className = 'dt-center', targets = '_all')
    ),
    stripeClasses = c('stripe1', 'stripe2')
  ),
  class = 'cell-border stripe hover'
) %>% formatStyle(
  'p_value', target = 'row',
  backgroundColor = styleInterval(0.05, c('white', 'yellow')),
  fontWeight = styleInterval(0.05, c('normal', 'bold'))
) %>% formatStyle(
  columns = c('Variable', 'C', 'R', 'p_value'),
  fontSize = '12px',
  fontFamily = 'Arial'
) %>% formatStyle(
  'Variable',
  whiteSpace = 'nowrap',
  overflow = 'hidden',
  textOverflow = 'ellipsis',
  maxWidth = '200px'
)

# Save the DT output as an HTML file
saveWidget(
  datatable(
    factor_summary_table_df,
    extensions = 'Buttons',
    options = list(
      dom = 'Bfrtip',
      buttons = list(
        'copy', 'csv', 'excel', 'pdf', 'print'
      ),
      pageLength = 10,
      autoWidth = TRUE,
      columnDefs = list(
        list(width = '150px', targets = 0),
        list(className = 'dt-center', targets = '_all')
      ),
      stripeClasses = c('stripe1', 'stripe2')
    ),
    class = 'cell-border stripe hover'
  ) %>% formatStyle(
    'p_value', target = 'row',
    backgroundColor = styleInterval(0.05, c('white', 'yellow')),
    fontWeight = styleInterval(0.05, c('normal', 'bold'))
  ) %>% formatStyle(
    columns = c('Variable', 'C', 'R', 'p_value'),
    fontSize = '12px',
    fontFamily = 'Arial'
  ) %>% formatStyle(
    'Variable',
    whiteSpace = 'nowrap',
    overflow = 'hidden',
    textOverflow = 'ellipsis',
    maxWidth = '200px'
  ),
  "factor_summary_table.html"
)


```

## Table 3: Categorical Outcomes by Setting
```{r}
#| echo: false
#| warning: false

# Function to clean up factor levels
clean_levels <- function(factor_var) {
  levels(factor_var) <- levels(factor_var) %>%
    str_replace_all("[^[:alnum:]]+", "_") %>%
    str_trim() %>%
    str_to_title() %>%
    str_replace_all("_+", "_") %>%
    str_replace_all("_$", "") %>%
    str_sub(1, 30)  # Optional: shorten levels to 30 characters max
  return(factor_var)
}

# Apply the function to clean up levels of all factor variables
cleaned_factors <- factor_vars %>%
  mutate(across(where(is.factor), clean_levels))

# Add the 'setting' variable back to the cleaned factor data frame
cleaned_factors <- cleaned_factors %>%
  mutate(setting = merged_clean$setting)

# Ensure that the 'setting' variable is a factor
cleaned_factors$setting <- as.factor(cleaned_factors$setting)

# Create a summary table for cleaned factor variables with <= 20 levels
factor_summary_table <- tbl_summary(
  data = cleaned_factors,
  by = "setting",
  missing = "no",
  statistic = list(
    all_categorical() ~ "{n} ({p}%)"
  )
) %>%
  add_p() %>%
  bold_labels() %>%
  modify_header(label ~ "**Variable**") %>%
  modify_caption("**Table 2: Descriptive Statistics for Factor Variables with ≤ 20 Levels by Setting**") %>%
  modify_footnote(
    all_stat_cols() ~ "N (%) for categorical variables"
  )

# Convert the gtsummary table to a data frame
factor_summary_table_df <- as_tibble(factor_summary_table, col_labels = TRUE)

# Rename columns to match expected names
colnames(factor_summary_table_df) <- c("Variable", "C", "R", "p_value")

# Render the table using DT with enhanced aesthetics
datatable(
  factor_summary_table_df,
  extensions = 'Buttons',
  options = list(
    dom = 'Bfrtip',
    buttons = list(
      'copy', 'csv', 'excel', 'pdf', 'print'
    ),
    pageLength = 10,
    autoWidth = TRUE,
    columnDefs = list(
      list(width = '300px', targets = 0),  # Set a fixed width for the first column
      list(className = 'dt-center', targets = '_all')
    ),
    stripeClasses = c('stripe1', 'stripe2')
  ),
  class = 'cell-border stripe hover'
) %>% formatStyle(
  'p_value', target = 'row',
  backgroundColor = styleInterval(0.05, c('white', 'yellow')),
  fontWeight = styleInterval(0.05, c('normal', 'bold'))
) %>% formatStyle(
  columns = c('Variable', 'C', 'R', 'p_value'),
  fontSize = '12px',
  fontFamily = 'Arial'
) %>% formatStyle(
  'Variable',
  whiteSpace = 'normal',
  wordWrap = 'break-word'
)

# Save the DT output as an HTML file
saveWidget(
  datatable(
    factor_summary_table_df,
    extensions = 'Buttons',
    options = list(
      dom = 'Bfrtip',
      buttons = list(
        'copy', 'csv', 'excel', 'pdf', 'print'
      ),
      pageLength = 10,
      autoWidth = TRUE,
      columnDefs = list(
        list(width = '300px', targets = 0),  # Set a fixed width for the first column
        list(className = 'dt-center', targets = '_all')
      ),
      stripeClasses = c('stripe1', 'stripe2')
    ),
    class = 'cell-border stripe hover'
  ) %>% formatStyle(
    'p_value', target = 'row',
    backgroundColor = styleInterval(0.05, c('white', 'yellow')),
    fontWeight = styleInterval(0.05, c('normal', 'bold'))
  ) %>% formatStyle(
    columns = c('Variable', 'C', 'R', 'p_value'),
    fontSize = '12px',
    fontFamily = 'Arial'
  ) %>% formatStyle(
    'Variable',
    whiteSpace = 'normal',
    wordWrap = 'break-word'
  ),
  "factor_summary_table.html"
)


```


 












