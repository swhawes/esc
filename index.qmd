---
title: "SPEP Revalidation"
#author: "Name Here"
---

## Preliminary Setup

::: panel-tabset

### Config Options

::: blue
> **This code configures knitr code chunk options**

```{r config}
#| echo: true
#| messages: FALSE
#| warning: FALSE
#| output: FALSE

knitr::opts_chunk$set(
    echo = T, message = F, warning = F, error = F,
    comment = NA, cache = T, code_folding = T,
    R.options = list(width = 220, digits = 3),
    fig.align = "center",
    out.width = "75%", fig.asp = .75
)
```
:::

### Install Packages {.tabset .tabset-fade .tabset-pills}

::: blue
> **This code loads the r packages necessary for this example**

```{r}
#| echo: true
#| warning: false
#| output: false

library(tidyverse)
library(readxl)
library(gtsummary)
library(DT)
library(patchwork)
library(dlookr)

```

:::

### Load Data
> **This code loads the dataframe**

```{r}
#| echo: true
#| warning: false
#| output: false

# Read the data from an Excel file
merged <- read_excel("/Users/shawes/PA_JCMS/data/Merged_Files_NoRecid.xlsx")
```

### Prep data {.tabset .tabset-fade .tabset-pills}

::: blue
> **This code prepares the dataset for analysis**

```{r}
#| echo: true
#| warning: false
#| output: false

## % Missingness by Variable

# Calculate the percentage of missing data for each column
missing_data_percentages <- merged %>%
  summarise(across(everything(), ~ mean(is.na(.)) * 100)) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "missing_percentage")

# Filter out columns with >= 90% missing data
columns_to_keep <- missing_data_percentages %>%
  filter(missing_percentage < 90) %>%
  pull(variable)

# Select the columns to keep
merged <- merged %>%
  select(all_of(columns_to_keep))
```

```{r}
#| echo: true
#| warning: false

## Prep data

# List of sensitive variables to exclude
sensitive_vars <- c("unique_id", "youth_num_in_cohort", "mhs2_juvenile_id", "dob", "assessment_po")

# Function to clean variable names
clean_variable_names <- function(merged) {
  cleaned_names <- merged %>%
    names() %>%
    str_replace_all("[^[:alnum:]_]", "_") %>%
    str_replace_all("__+", "_") %>%
    str_trim() %>%
    tolower()
  
  # Ensure unique names
  cleaned_names <- make.unique(cleaned_names)
  
  names(merged) <- cleaned_names
  return(merged)
}

# Function to calculate means and standard deviations for numeric columns
calculate_means_sds <- function(merged) {
  means_sds <- sapply(merged, function(x) if(is.numeric(x)) {
    mean_value <- round(mean(x, na.rm = TRUE), 2)
    sd_value <- round(sd(x, na.rm = TRUE), 2)
    paste0(mean_value, " (", sd_value, ")")
  } else NA)
  return(means_sds)
}

# Function to set variable types based on dlookr diagnostics
set_variable_types <- function(merged, types) {
  for (i in 1:nrow(types)) {
    var <- types$variables[i]
    type <- types$types[i]
    if (type == "numeric") {
      merged[[var]] <- as.numeric(merged[[var]])
    } else if (type == "factor") {
      merged[[var]] <- as.factor(merged[[var]])
    } else if (type == "integer") {
      merged[[var]] <- as.integer(merged[[var]])
    } else if (type == "character") {
      merged[[var]] <- as.character(merged[[var]])
    }
    # Add other types as necessary
  }
  return(merged)
}

# Function to convert character variables to factors if they have a limited number of unique values
convert_char_to_factor <- function(merged) {
  merged <- merged %>%
    mutate(across(where(is.character), as.factor))
  return(merged)
}

# Function to calculate the mode for factor variables
calculate_modes <- function(merged) {
  modes <- sapply(merged, function(x) if(is.factor(x)) {
    mode_value <- names(sort(table(x), decreasing = TRUE)[1])
    mode_count <- max(table(x))
    mode_percentage <- (mode_count / length(x)) * 100
    paste0(mode_value, " (", round(mode_percentage, 2), "%)")
  } else NA)
  return(modes)
}

# Function to calculate date statistics for POSIXct columns
calculate_date_statistics <- function(merged) {
  date_stats <- sapply(merged, function(x) if(inherits(x, "POSIXct")) {
    min_date <- format(min(x, na.rm = TRUE), "%Y-%m-%d")
    max_date <- format(max(x, na.rm = TRUE), "%Y-%m-%d")
    num_unique_dates <- length(unique(x))
    median_date <- format(median(x, na.rm = TRUE), "%Y-%m-%d")
    paste0(min_date, " to ", max_date)
  } else NA)
  return(date_stats)
}

# Function to count the number of levels for factor variables
count_levels <- function(merged) {
  num_levels <- sapply(merged, function(x) if(is.factor(x)) length(levels(x)) else NA)
  return(num_levels)
}

# Function to mask sensitive data, only for existing columns
mask_sensitive_data <- function(merged, sensitive_vars) {
  existing_sensitive_vars <- intersect(names(merged), sensitive_vars)
  if(length(existing_sensitive_vars) > 0) {
    merged <- merged %>%
      mutate(across(all_of(existing_sensitive_vars), ~ "Masked"))
  }
  return(merged)
}

# List of sensitive variables to exclude
sensitive_vars <- c("youth_num_in_cohort", "mhs2_juvenile_id", "dob", "assessment_po")
# "unique_id" 

# Apply the cleaning function to the dataset
merged_clean <- clean_variable_names(merged)

# Convert character variables to factors
merged_clean <- convert_char_to_factor(merged_clean)

# Determine variable types using dlookr
variable_types <- diagnose(merged_clean) %>%
  select(variables, types)

# Set variable types based on dlookr diagnostics
merged_clean <- set_variable_types(merged_clean, variable_types)

# Mask sensitive data
merged_clean <- mask_sensitive_data(merged_clean, sensitive_vars)

# Create a mapping table of original and cleaned names, excluding sensitive variables
mapping_table <- tibble(
  original_name = names(merged),
  cleaned_name = names(merged_clean)
) %>%
  filter(!cleaned_name %in% sensitive_vars)

# Calculate means and standard deviations for numeric columns
means_sds <- calculate_means_sds(merged_clean)

# Calculate modes for factor columns
modes <- calculate_modes(merged_clean)

# Calculate date statistics for POSIXct columns
date_statistics <- calculate_date_statistics(merged_clean)

# Count the number of levels for factor variables
num_levels <- count_levels(merged_clean)

# Combine means, modes, date statistics, and sensitive summaries into separate columns
mapping_table <- mapping_table %>%
  mutate(mean_sd = means_sds[!names(means_sds) %in% sensitive_vars],
         mode = modes[!names(modes) %in% sensitive_vars],
         date_range = date_statistics[!names(date_statistics) %in% sensitive_vars],
         num_levels = num_levels[!names(num_levels) %in% sensitive_vars]) %>%
  left_join(variable_types, by = c("cleaned_name" = "variables"))

# Ensure all numeric values in the table are rounded to two decimal places
mapping_table <- mapping_table %>%
  mutate(across(where(is.numeric), ~ round(., 2)))

# Reorder the columns so that summary_statistic is before original_name
mapping_table <- mapping_table %>%
  select(cleaned_name, mean_sd, mode, date_range, num_levels, original_name, types)
```

:::
:::

## Descriptives Overview

::: panel-tabset

### General Data View {.tabset .tabset-fade .tabset-pills}

::: blue

> **This table shows some general info for full sample (including duplicates), will probably be removed later**

```{r}
#| echo: true
#| warning: false

# Render the table using DT::datatable with tooltips and better formatting
datatable(mapping_table, 
          rownames = FALSE,
          caption = 'Summary Statistics Table',
          extensions = 'Buttons',
          options = list(
            pageLength = 10,
            scrollX = TRUE,
            scrollY = "500px",
            dom = 'Bfrtip',
            buttons = c('copy', 'csv', 'excel', 'pdf', 'print')
          )) %>%
  formatStyle(
    columns = names(mapping_table),
    valueColumns = "types",
    backgroundColor = styleEqual(c("numeric", "factor", "POSIXct"), c("lightblue", "lightgreen", "lightpink"))
  )

```
:::

### Descriptives

::: blue
> **This code creates a basic descriptives table by setting (community vs residential)**

```{r}
#| echo: true
#| warning: false

# Obtain the variable names from the merged dataframe
variables <- names(merged_clean)

# Filter variables that include the sequence "yls"
filtered_variables <- grep("yls", variables, value = TRUE)

# Print the filtered variables
#print(filtered_variables)

# Create a test dataframe with the specified variables
test_df <- merged_clean %>%
  select(
    "age_at_service_start",
    "gender",
    "race",
    "ethnicity",
    "racnicity",
    "age_at_first_referral_date",
    #youth_num_in_cohort,
    #number_of_youth_scoring_low_on_the_yls,
    #number_of_youth_scoring_moderate_on_the_yls,
    #number_of_youth_scoring_high_on_the_yls,
    #number_of_youth_scoring_very_high_on_the_yls,
    #points_received_risk_level_of_youth_youth_scoring_above_low_on_the_yls,
    #points_received_risk_level_of_youth_youth_scoring_above_moderate_on_the_yls,
    setting
  )

# Create a summary table for the full sample
full_sample_summary <- tbl_summary(
  test_df,
  by = setting,
  statistic = list(
    all_continuous() ~ "{mean} ({sd})",
    all_categorical() ~ "{n} ({p}%)"
  ),
  missing = "no"
) %>%
  add_p() %>%
  bold_labels() %>%
  modify_header(label ~ "**Variable**") %>%
  modify_caption("**Descriptive Statistics by Setting**") %>%
  modify_footnote(
    all_stat_cols() ~ "Mean (SD) for continuous variables, N (%) for categorical variables"
  )

# Display the summary table
full_sample_summary

```

:::

### Service Type

::: blue
> **This code creates a basic descriptives table for Service Type (full sample)**

```{r}
#| echo: true
#| warning: false

# Create a test dataframe with the specified variables
test_df <- merged_clean %>%
  select(
    service_type
  )

# Create a summary table for 'service_type'
service_type_summary <- tbl_summary(
  test_df,
  statistic = list(
    all_categorical() ~ "{n} ({p}%)"
  ),
  missing = "no"
) %>%
  bold_labels() %>%
  modify_header(label ~ "**Service Type**") %>%
  modify_caption("**Distribution of Service Type**") %>%
  modify_footnote(
    all_stat_cols() ~ "N (%) for categorical variables"
  )

# Display the summary table
service_type_summary

```

> **This code creates a basic descriptives table for Service Type (no duplicates)**

```{r}


# Convert SERVICE_START_DATE to Date type if it's not already
merged$SERVICE_START_DATE <- as.Date(merged$SERVICE_START_DATE, format = "%Y-%m-%d")

# Filter to keep the row with the earliest SERVICE_START_DATE for each UNIQUE_ID
filtered_df <- merged %>%
  group_by(UNIQUE_ID) %>%
  filter(SERVICE_START_DATE == min(SERVICE_START_DATE, na.rm = TRUE)) %>%
  ungroup()

# Create a test dataframe with the specified variable
test_df <- filtered_df %>%
  select(Service_Type)

# Create a summary table for 'service_type'
service_type_summary <- tbl_summary(
  test_df,
  statistic = list(
    all_categorical() ~ "{n} ({p}%)"
  ),
  missing = "no"
) %>%
  bold_labels() %>%
  modify_header(label ~ "**Service Type**") %>%
  modify_caption("**Distribution of Service Type**") %>%
  modify_footnote(
    all_stat_cols() ~ "N (%) for categorical variables"
  )

# Display the summary table
service_type_summary

```
:::

### Risk Scores {.tabset .tabset-fade .tabset-pills}

::: blue

> **This table shows xxxxxx (full-sample)**

```{r}

# # Convert SERVICE_START_DATE to Date type if it's not already
# merged$SERVICE_START_DATE <- as.Date(merged$SERVICE_START_DATE, format = "%Y-%m-%d")
# 
# # Filter to keep the row with the earliest SERVICE_START_DATE for each UNIQUE_ID
# filtered_df <- merged %>%
#   group_by(UNIQUE_ID) %>%
#   filter(SERVICE_START_DATE == min(SERVICE_START_DATE, na.rm = TRUE)) %>%
#   ungroup()

# Convert Total_Risk_Desc to a factor
merged$Total_Risk_Desc <- as.factor(merged$Total_Risk_Desc)

# Create a test dataframe with the specified variables
test_df <- merged %>%
  select(Total_Risk_Desc, TOTALSCORE)

# Create summary table for 'Total_Risk_Desc'
total_risk_desc_summary <- tbl_summary(
  test_df %>% select(Total_Risk_Desc),
  statistic = list(
    all_categorical() ~ "{n} ({p}%)"
  ),
  missing = "no"
) %>%
  bold_labels() %>%
  modify_header(label ~ "**Total Risk Description**") %>%
  modify_caption("**Distribution of Total Risk Description**") %>%
  modify_footnote(
    all_stat_cols() ~ "N (%) for categorical variables"
  )

# Create summary table for 'TOTALSCORE'
totalscore_summary <- tbl_summary(
  test_df %>% select(TOTALSCORE),
  statistic = list(
    all_continuous() ~ "{mean} ({sd})"
  ),
  missing = "no"
) %>%
  bold_labels() %>%
  modify_header(label ~ "**Total Score**") %>%
  modify_caption("**Descriptive Statistics for Total Score**") %>%
  modify_footnote(
    all_stat_cols() ~ "Mean (SD) for continuous variables"
  )

# Convert summary tables to gt tables
total_risk_desc_gt <- as_gt(total_risk_desc_summary)
totalscore_gt <- as_gt(totalscore_summary)

# Display the summary tables side by side using gt
#library(gt)
#gt::gtsave(total_risk_desc_gt, "total_risk_desc_summary.html")
#gt::gtsave(totalscore_gt, "totalscore_summary.html")

total_risk_desc_gt
totalscore_gt


```
:::

### Risk Scores II

::: blue
> **This code creates a basic descriptives table for Service Type (no duplicates)**

```{r}

# Convert SERVICE_START_DATE to Date type if it's not already
merged$SERVICE_START_DATE <- as.Date(merged$SERVICE_START_DATE, format = "%Y-%m-%d")

# Filter to keep the row with the earliest SERVICE_START_DATE for each UNIQUE_ID
filtered_df <- merged %>%
  group_by(UNIQUE_ID) %>%
  filter(SERVICE_START_DATE == min(SERVICE_START_DATE, na.rm = TRUE)) %>%
  ungroup()

# Convert Total_Risk_Desc to a factor
filtered_df$Total_Risk_Desc <- as.factor(filtered_df$Total_Risk_Desc)

# Create a test dataframe with the specified variables
test_df <- filtered_df %>%
  select(Total_Risk_Desc, TOTALSCORE)

# Create summary table for 'Total_Risk_Desc'
total_risk_desc_summary <- tbl_summary(
  test_df %>% select(Total_Risk_Desc),
  statistic = list(
    all_categorical() ~ "{n} ({p}%)"
  ),
  missing = "no"
) %>%
  bold_labels() %>%
  modify_header(label ~ "**Total Risk Description**") %>%
  modify_caption("**Distribution of Total Risk Description**") %>%
  modify_footnote(
    all_stat_cols() ~ "N (%) for categorical variables"
  )

# Create summary table for 'TOTALSCORE'
totalscore_summary <- tbl_summary(
  test_df %>% select(TOTALSCORE),
  statistic = list(
    all_continuous() ~ "{mean} ({sd})"
  ),
  missing = "no"
) %>%
  bold_labels() %>%
  modify_header(label ~ "**Total Score**") %>%
  modify_caption("**Descriptive Statistics for Total Score**") %>%
  modify_footnote(
    all_stat_cols() ~ "Mean (SD) for continuous variables"
  )

# Convert summary tables to gt tables
total_risk_desc_gt <- as_gt(total_risk_desc_summary)
totalscore_gt <- as_gt(totalscore_summary)

# Display the summary tables side by side using gt
#library(gt)
#gt::gtsave(total_risk_desc_gt, "total_risk_desc_summary.html")
#gt::gtsave(totalscore_gt, "totalscore_summary.html")

total_risk_desc_gt
totalscore_gt



```


:::
:::









 












